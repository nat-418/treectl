#!/usr/bin/env tclsh

package require Tcl 8.6

set version 0.0.1

set help [string trim "
treectl v$version | A command-line tool to help manage git worktrees

Usage:
  treectl \[command\] \[options\] \[arguments\]

Options:
  -gh, --gh    Use GitHub CLI instead of git CLI for cloning

Commands:
  list-all                   List all local worktrees
  find-path  NAME            Show the path to a given local worktree
  init-clone REMOTE LOCAL    Clone a worktree-optimized remote repository
"]

proc checkPath {path} {
  if {$path eq ""} {
    set path .
  }

  if {![file exists [file join $path .git]]} {
    puts stderr "Error: not a git directory"
    exit 1
  } else {
    return $path
  }
}

proc listTrees {path} {
  cd $path

  foreach line [split [exec git worktree list --porcelain] "\n"] {
    set segments [split $line]

    if {[lindex $segments 0] eq "branch"} {
      set name [lindex [split [lindex $segments 1] "/"] end]
      lappend results $name
    }
  }

  return $results
}

proc findgit_root {path {result ""}} {
  set result [file normalize [file dirname .]]

  cd ..

  if {[file exists .git]} {
    if {[file isdirectory ..]} {
      tailcall findgit_root ..
    }
  } else {
    cd $path
    return $result
  }
}

proc initClone {arguments} {
  set first_arg      [lindex $arguments 0]
  set remote         $first_arg
  set local          [lindex $arguments 1]
  set clone_cmd      "git clone --bare $remote .git"
  set use_GitHub_CLI [expr {$first_arg eq "-gh" || $first_arg eq "--gh"}]

  if $use_GitHub_CLI {
    set remote    [lindex $arguments 1]
    set local     [lindex $arguments 2]
    set clone_cmd "gh repo clone $remote .git -- --bare"
  }

  if {[file exists $local]} {
    puts stderr "Error: local directory '$local' already exists."
    exit 1
  }

  puts "mkdir $local"
  file mkdir $local

  puts "cd $local"
  cd $local

  # gh repo clone exits with an error code even when the clone succeeds (?)
  if $use_GitHub_CLI {
    puts $clone_cmd
    try {
      exec {*}$clone_cmd
    } on error message {
      puts $message
    }
  } else {
    puts $clone_cmd
    try {
      exec {*}$clone_cmd
    } on error message {
      puts $message
      exit 1
    }
  }

  foreach branch {dev develop main master current} {
    if {[exec git ls-remote --heads origin $branch] ne ""} {
      puts [exec git worktree add $branch]
    }
  }
}

proc findPath {treePaths treeName} {
  if {$treeName eq ""} {
    puts stderr "Error: no tree name given"
    exit 1
  }

  try {
    return [dict get $treePaths $treeName]
  } on error message {
    puts stderr "Error: could not find path to '$treeName'"
    exit 1
  }
}

set command   [lindex $argv 0]
set arguments [lrange $argv 1 end]

if {$command eq "list-all" || $command eq "find-path"} {
  set path     [checkPath [file normalize .]]
  set git_root [findgit_root $path]

  foreach tree [listTrees $path] {
    dict set worktree_paths $tree [file join $git_root $tree]
  }
}

try {
  switch -glob $command {
    "list-all"   {puts [join [dict keys $worktree_paths] "\n"]}
    "find-path"  {puts [findPath $worktree_paths [lindex $arguments 0]]}
    "init-clone" {initClone $arguments}
    default      {puts $help}
  }
} on error message {
  puts stderr $message
  exit 1
}
